<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>pandas</title>
      <link href="/2019/03/13/pandas/"/>
      <url>/2019/03/13/pandas/</url>
      
        <content type="html"><![CDATA[<p><a href="https://i.loli.net/2019/03/13/5c88814ef04c5.png" target="_blank" rel="noopener"><img src="https://i.loli.net/2019/03/13/5c88814ef04c5.png" alt="思维导图"></a><br>原文件地址：<a href="https://mubu.com/doc/3DH__vzNYa" target="_blank" rel="noopener">https://mubu.com/doc/3DH__vzNYa</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无重复字符的最长子串</title>
      <link href="/2019/03/12/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/"/>
      <url>/2019/03/12/%E6%97%A0%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E6%9C%80%E9%95%BF%E5%AD%90%E4%B8%B2/</url>
      
        <content type="html"><![CDATA[<p>给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。</p><a id="more"></a><p><strong>示例 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;abcabcbb&quot;</span><br><span class="line">输出: 3 </span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</span><br></pre></td></tr></table></figure><p><strong>示例 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;bbbbb&quot;</span><br><span class="line">输出: 1</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</span><br></pre></td></tr></table></figure><p><strong>示例 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;pwwkew&quot;</span><br><span class="line">输出: 3</span><br><span class="line">解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。</span><br><span class="line">     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</span><br></pre></td></tr></table></figure><hr><p>1 字典st记录字符出现的位置，两个相同字符之间的距离，就是无重复字符的长度</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        st = &#123;&#125;</span><br><span class="line">        i, ans = -1, 0</span><br><span class="line">        for j in range(len(s)):</span><br><span class="line">            if s[j] in st:</span><br><span class="line">                i = max(st[s[j]], i)</span><br><span class="line">            ans = max(ans, j - i)</span><br><span class="line">            st[s[j]] = j</span><br><span class="line">        return ans</span><br></pre></td></tr></table></figure><p>2</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">class Solution(object):</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        maxnum,num,ss =0,0,&apos;&apos;</span><br><span class="line">        for each in s:</span><br><span class="line">            if each in ss:</span><br><span class="line">                ss = ss.split(each)[-1]+each</span><br><span class="line">                num =len(ss)</span><br><span class="line">            else:</span><br><span class="line">                num += 1</span><br><span class="line">                ss += each</span><br><span class="line">                if num&gt;=maxnum:</span><br><span class="line">                    maxnum = num</span><br><span class="line"></span><br><span class="line">        return maxnum</span><br></pre></td></tr></table></figure><p>3</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        res, start, n = 0, 0, len(s)</span><br><span class="line">        maps = &#123;&#125;</span><br><span class="line">        for i in range(n):</span><br><span class="line">            start = max(start, maps.get(s[i], -1)+1)</span><br><span class="line">            res = max(res, i - start + 1)</span><br><span class="line">            maps[s[i]] = i</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure><p>4</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">class Solution:</span><br><span class="line">    def lengthOfLongestSubstring(self, s):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type s: str</span><br><span class="line">        :rtype: int</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        lookup = collections.defaultdict(int)</span><br><span class="line">        l, r, counter, res = 0, 0, 0, 0</span><br><span class="line">        while r &lt; len(s):</span><br><span class="line">            lookup[s[r]] += 1</span><br><span class="line">            if lookup[s[r]] == 1:</span><br><span class="line">                counter += 1</span><br><span class="line">            r += 1</span><br><span class="line">            # counter &lt; r - l 说明有重复字符出现，正常为counter == r - l</span><br><span class="line">            while l &lt; r and counter &lt; r - l:</span><br><span class="line">                lookup[s[l]] -= 1</span><br><span class="line">                if lookup[s[l]] == 0:</span><br><span class="line">                    counter -= 1</span><br><span class="line">                l += 1</span><br><span class="line">            res = max(res, r - l)</span><br><span class="line">        return res</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性回归</title>
      <link href="/2019/03/12/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/"/>
      <url>/2019/03/12/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92/</url>
      
        <content type="html"><![CDATA[<p>线性回归本质上是一个函数估计的问题，即找出自变量与因变量的关系。</p><ul><li>因变量是连续的，回归</li><li>因变量是离散的，分类<br>回归分析是一个有监督的学习<a id="more"></a><h2 id="简单线性回归"><a href="#简单线性回归" class="headerlink" title="简单线性回归"></a>简单线性回归</h2>假设某个体x有d个特征，即x=(x^1,x^2,…,x^d)，x^i是第i个特征，线性模型(linear model)试图通过特征的线性组合得到预测值，即<br>$$<br>f(x)=w^{T}x+b=w_{1}x^{1}+w_{2}x^{2}+…+w_{d}x^{n}+b<br>$$<!--more-->其中当w_{i}是第个特征的权重，既能调节特征的量纲，也能显示该特征对预测值的重要程度；是第i个特征的权重，既能调节特征的量纲，也能显示该特征对预测值的重要程度<br>$$<br>w^{T}=（w_{1}，w_{2}，…，w_{d}）<br>$$</li></ul><p>$$<br>x^{T}=（x_{1}，x_{2}，…，x_{d}）<br>$$</p><p>b代表预测值中非代表预测值中非x所能影响的那部分；当所能影响的那部分；当d=1时，便是最简单的线性模型时，便是最简单的线性模型<br>$$<br>f(x)=wx+b<br>$$</p><p>线性回归试图学习f(x_i)=wx_i+b，使得f(x_i)≈y_i<br>$$<br>g(w,b)=\sum_{i=1}^{n}(f(x_{i})-y_{i})^{2}=\sum_{i=1}^{n}(wx_{i}+b-y_{i})^{2}<br>$$<br>让g(w,b)取得最小值。因此我们可以用偏导数求解：<br>$$<br>\frac{\partial g(w,b)}{\partial w}=0\<br>\frac{\partial g(w,b)}{\partial b}=0<br>$$</p><p>&emsp;&emsp;解出：</p><p>$$<br>w=\frac{\sum_{i=1}^{n}y_{i}(x_{i}-\bar{x})}{\sum_{i=1}^{n}x_{i}^2-n\bar{x}^{2}}\<br>b=\bar{y}-w\bar{x}\<br>\bar{x}=\frac{1}{n}\sum_{i=1}^{n}x_{i}\<br>\bar{y}=\frac{1}{n}\sum_{i=1}^{n}y_{i}<br>$$<br>推导过程如下：</p><ul><li><p>先求b:<br>$$<br>\frac{\partial g(w,b)}{\partial b}=\sum_{i=1}^{n}(y_{i}-wx_i-b)(-1)<br>=\sum_{i=1}^{n}(y_{i}-wx_i-b)=0<br>$$<br>化简得：<br>$$<br>\sum_{i=1}^{n}y_i-w\sum_{i=1}^{n}x_i-\sum_{i=1}^{n}b=\sum_{i=1}^{n}y_i-w\sum_{i=1}^{n}x_i-mb=0<br>$$<br>即：<br>$$<br>mb=\sum_{i=1}^{n}y_i-w\sum_{i=1}^{n}x_i<br>$$<br>即：<br>$$<br>b=\bar{y}-w\bar{x}<br>$$</p><ul><li><p>再求w<br>$$<br>\frac{\partial g(w,b)}{\partial b}=\sum_{i=1}^{n}2(y_{i}-wx_i-b)(-x_i)=\sum_{i=1}^{n}(y_{i}-wx_i-b)x_i=0<br>$$<br>代入b：<br>$$<br>\frac{\partial g(w,b)}{\partial b}=\sum_{i=1}^{n}(y_i-wx_i-\bar{y}+w\bar{x})x_i=0<br>$$<br>即：<br>$$<br>\sum_{i=1}^{n}(x_iy_i-wx_i^2-x_i\bar{y}+wx_i\bar{x})=0<br>$$<br>即：<br>$$<br>\sum_{i=1}^{n}(x_iy_i-x_i\bar{y})=\sum_{i=1}^{n}(wx_i^2-wx_i\bar{x})<br>$$<br>即：<br>$$<br>w=\frac{\sum_{i=1}^{n}(x_iy_i-x_i\bar{y})}{\sum_{i=1}^{n}(x_i^2-x_i\bar{x})}<br>$$<br>w的解这样看起来很复杂，可以进一步优化</p><p>其中：<br>$$<br>\sum_{i=1}^{n}x_i\bar{y}=\bar{y}\sum_{i=1}^{n}x_i=n\bar{y}\bar{x}=\bar{x}\sum_{i=1}^{n}\bar{y}=\sum_{i=1}^{n}\bar{x}y_i=\sum_{i=1}^{n}\bar{x}\bar{y}<br>$$</p></li></ul></li></ul><p>​             所以：<br>$$<br>w=\frac{\sum_{i=1}^{n}(x_iy_i-x_i\bar{y}-\bar{x}y_i+\bar{x}\bar{y})}{\sum_{i=1}^{n}(x_i^2-x_i\bar{x}-\bar{x}x_i+\bar{x})}=\frac{\sum_{i=1}^{n}(x_i-\bar{x})(y_i-\bar{y})}{\sum_{i=1}^{n}(x_i-\bar{x})^2}<br>$$</p><h2 id="实现简单线性回归"><a href="#实现简单线性回归" class="headerlink" title="实现简单线性回归"></a>实现简单线性回归</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line">x = np.array([<span class="number">1.</span>,<span class="number">2.</span>,<span class="number">3.</span>,<span class="number">4.</span>,<span class="number">5.</span>])</span><br><span class="line">y = np.array([<span class="number">2.</span>,<span class="number">3.</span>,<span class="number">4.</span>,<span class="number">3.</span>,<span class="number">5.</span>])</span><br><span class="line">x_mean = np.mean(x)</span><br><span class="line">y_mean = np.mean(y)</span><br><span class="line">n = d = <span class="number">0.0</span></span><br><span class="line"><span class="keyword">for</span> x_i, y_i <span class="keyword">in</span> zip(x, y):</span><br><span class="line">n += (x_i-x_mean)*(y_i-y_mean)</span><br><span class="line">d += (x_i-x_mean)**<span class="number">2</span></span><br><span class="line">w = n/d</span><br><span class="line">b = y_mean - w*x_mean</span><br><span class="line">y_hat = a*x + b</span><br></pre></td></tr></table></figure><h3 id="线性回归的评价指标"><a href="#线性回归的评价指标" class="headerlink" title="线性回归的评价指标"></a>线性回归的评价指标</h3><p>均方误差 MSE：$\frac{1}{n}\sum_{i=1}^{n}(y_i-\hat{y_i})^2$</p><p>均方根误差 RMSE $\sqrt{\frac{1}{n}\sum_{i=1}^{n}(y_i-\hat{y_i})^2}$</p><p>平均绝对误差 MAE:  $\frac{1}{n}\sum_{i=1}^{n}|y_i-\hat{y_i}|$</p><p>R-squared : $1 - \frac{MSE(\hat{y}, y)}{Var(y)}$</p><h2 id="多元线性回归"><a href="#多元线性回归" class="headerlink" title="多元线性回归"></a>多元线性回归</h2><p>目标：使\sum_{i=1}^{m}(y_i-\hat{y_i})^2,尽可能的小<br>$$<br>\hat{y}^{i}=w_0+w_1{x_1}^{i}+w_2{x_2}^{i}+…+w_n{x_n}^{i}<br>$$</p><p>即找到${w_0,w_1,w_2,…,w_n}$,使得目标值 尽可能地小</p><p>设<br>$$<br>W = \mathbf{(w_0,w_1,w_2,…,w_n)}^\mathrm{T}<br>$$</p><p>$$<br>\hat{y}^{i}=w_0{x_0}^{i}+w_1{x_1}^{i}+w_2{x_2}^{i}+…+w_n{x_n}^{i},{x_0}^{i}\equiv1<br>$$</p><p>$$<br>X^{i} = \mathbf{(X_0^{i},X_1^{i},X_2^{i},…,X_n^{i})}^\mathrm{T}<br>$$</p><p>$$<br>\hat{y}^{i}=X^{i}W<br>$$</p><p>推广：<br>$$<br>X_b=\begin{pmatrix}<br>        1 &amp; X_1^{(1)} &amp; X_2^{(1)} &amp; \cdots &amp; X_n^{(1)} \<br>        1 &amp;  X_1^{(2)} &amp; X_2^{(2)} &amp; \cdots &amp; X_n^{(2)} \<br>        \vdots &amp; \vdots &amp; \vdots &amp; \ddots &amp; \vdots \<br>        1 &amp;  X_1^{(m)} &amp; X_2^{(m)} &amp; \cdots &amp; X_n^{(m)} \<br>        \end{pmatrix}<br>$$<br>$$<br>W =\begin{pmatrix}<br>        W_0\W_1\W_2\\vdots \W_n<br>        \end{pmatrix}<br>$$<br>$$<br>\hat{y}=X_bW<br>$$</p><p>使得目标值尽量小，即：<br>$$<br>J(W)=\sum_{i=1}^{m}(y_i-\hat{y_i})^2=\mathbf{(Y-X_bW)}^\mathrm{T}(Y-X_bW)<br>$$<br>这里还需要用到向量内积对向量求导的知识，对同维度的两个向量U,V,二者向量内积对任意维列向量X求导<br>$$<br>\frac{d(\mathbf{U}^\mathrm{T}V)}{dx}=\frac{d(\mathbf{U}^\mathrm{T})}{dx}V+\frac{d(\mathbf{X}^\mathrm{T})}{dx}U<br>$$<br>同理<br>$$<br>\frac{d(\mathbf{X}^\mathrm{T}X)}{dx}=\frac{d(\mathbf{X}^\mathrm{T})}{dx}X+\frac{d(\mathbf{X}^\mathrm{T})}{dx}X=2IX=2X<br>$$</p><p>$$<br>\frac{d(\mathbf{X}^\mathrm{T}X)}{dy}=\frac{d(\mathbf{X}^\mathrm{T})}{dy}X+\frac{d(\mathbf{X}^\mathrm{T})}{dy}X=2\frac{d(X^T)}{dy}X<br>$$</p><p>则：<br>$$<br>\frac{\partial J(W)}{\partial W}=\frac{2\partial\mathbf{(Y-X_bW)}^\mathrm{T}}{\partial W}（Y-X_bW)<br>$$</p><p>$$<br>=2\frac{\partial \mathbf{Y}^\mathrm{T}}{\partial W}(Y-X_bW)-2\frac{\partial \mathbf{(X_bW)}^\mathrm{T}}{\partial W}(Y-X_bW)<br>$$</p><p>$$<br>=0 - 2\mathbf{X_b}^{T}(Y-X_bW)<br>$$</p><p>在处理较为复杂的数据的回归问题时，普通的线性回归算法通常会出现预测精度不够，如果模型中的特征之间有相关关系，就会增加模型的复杂程度，并且对整个模型的解释能力并没有提高，这时，就需要对数据中的特征进行选择。</p><h2 id="岭回归（Ridge-Redression）"><a href="#岭回归（Ridge-Redression）" class="headerlink" title="岭回归（Ridge Redression）"></a>岭回归（Ridge Redression）</h2><p>在平方误差的基础上加上正则项<br>$$<br>J(θ)=\frac{1}{m}\sum_{i=1}^{m}(y^{(i)}−(wx^{(i)}+b))^2+λ||w||<em>2^2=MSE(θ)+λ\sum</em>{i=1}^{n}θ<em>i^2<br>$$<br>通常也写成如下形式：<br>$$<br>J(θ)=\frac{1}{2m}\sum</em>{i=1}^{m}(y^{(i)}−(wx^{(i)}+b))^2+\frac{λ}{2}||w||<em>2^2=\frac{1}{2}MSE(θ)+\frac{λ}{2}\sum</em>{i=1}^{n}θ_i^2<br>$$<br>上式中的w是长度为n的向量，不包括截距项的系数$θ_0$；θ是长度为n+1的向量，包括截距项的系数$θ_0$；m为样本数；n为特征数.</p><p>全局最优解为：<br>$$<br>θ=(\mathbf{X}^\mathrm{T}X+λI)^{−1}(\mathbf{X}^\mathrm{T}y)<br>$$</p><h2 id="Lasso回归"><a href="#Lasso回归" class="headerlink" title="Lasso回归"></a>Lasso回归</h2><p>加入L1正则项</p><p>代价函数为：<br>$$<br>J(θ)=\frac{1}{2m}\sum_{i=1}^{m}(y^{(i)}−(wx^{(i)}+b))^2+λ||w||<em>1=\frac{1}{2}MSE(θ)+λ\sum</em>{i=1}^{n}θ_i<br>$$<br>上式中的w是长度为n的向量，不包括截距项的系数$θ_0$, θθ是长度为n+1的向量，包括截距项的系数$θ_0$，m为样本数，n为特征数.</p>]]></content>
      
      
      
        <tags>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>两数相加</title>
      <link href="/2019/03/11/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
      <url>/2019/03/11/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/</url>
      
        <content type="html"><![CDATA[<p>原题链接：<a href="https://leetcode-cn.com/problems/add-two-numbers/comments/" target="_blank" rel="noopener">https://leetcode-cn.com/problems/add-two-numbers/comments/</a></p><p>给出两个 <strong>非空</strong> 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 <strong>逆序</strong> 的方式存储的，并且它们的每个节点只能存储 <strong>一位</strong> 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><a id="more"></a><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span><br><span class="line">输出：7 -&gt; 0 -&gt; 8</span><br><span class="line">原因：342 + 465 = 807</span><br></pre></td></tr></table></figure><hr><p>1 依次计算<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"># class ListNode:</span></span><br><span class="line"><span class="comment">#     def __init__(self, x):</span></span><br><span class="line"><span class="comment">#         self.val = x</span></span><br><span class="line"><span class="comment">#         self.next = None</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        add = <span class="number">0</span></span><br><span class="line">        l3 = ListNode(<span class="number">0</span>)</span><br><span class="line">        node = l3</span><br><span class="line">        <span class="keyword">while</span> l1 <span class="keyword">or</span> l2:</span><br><span class="line">            cur = ListNode(add)</span><br><span class="line">            <span class="keyword">if</span> l1:</span><br><span class="line">                cur.val += l1.val</span><br><span class="line">                l1 = l1.next</span><br><span class="line">            <span class="keyword">if</span> l2:</span><br><span class="line">                cur.val += l2.val</span><br><span class="line">                l2 = l2.next</span><br><span class="line">            add = cur.val // <span class="number">10</span></span><br><span class="line">            cur.val = cur.val % <span class="number">10</span></span><br><span class="line">            node.next, node = cur, cur</span><br><span class="line">        <span class="keyword">if</span> add:</span><br><span class="line">            node.next = ListNode(add)</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> l3.next</span><br></pre></td></tr></table></figure></p><p>2 全部变成数字，然后再转换回来<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1:</span><br><span class="line">            <span class="keyword">return</span> l2</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> l1</span><br><span class="line">        </span><br><span class="line">        val1, val2 = [l1.val], [l2.val]</span><br><span class="line">        <span class="keyword">while</span> l1.next:</span><br><span class="line">            val1.append(l1.next.val)</span><br><span class="line">            l1 = l1.next</span><br><span class="line">        <span class="keyword">while</span> l2.next:</span><br><span class="line">            val2.append(l2.next.val)</span><br><span class="line">            l2 = l2.next</span><br><span class="line">            </span><br><span class="line">        num1 = <span class="string">''</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> val1[::<span class="number">-1</span>]])</span><br><span class="line">        num2 = <span class="string">''</span>.join([str(i) <span class="keyword">for</span> i <span class="keyword">in</span> val2[::<span class="number">-1</span>]])</span><br><span class="line">        </span><br><span class="line">        tmp = str(int(num1) + int(num2))[::<span class="number">-1</span>]</span><br><span class="line">        res = ListNode(int(tmp[<span class="number">0</span>]))</span><br><span class="line">        run_res = res</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1</span>, len(tmp)):</span><br><span class="line">            run_res.next = ListNode(int(tmp[i]))</span><br><span class="line">            run_res = run_res.next</span><br><span class="line">        <span class="keyword">return</span> res</span><br></pre></td></tr></table></figure></p><p>3 使用递归<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">addTwoNumbers</span><span class="params">(self, l1, l2)</span>:</span></span><br><span class="line">        <span class="string">"""</span></span><br><span class="line"><span class="string">        :type l1: ListNode</span></span><br><span class="line"><span class="string">        :type l2: ListNode</span></span><br><span class="line"><span class="string">        :rtype: ListNode</span></span><br><span class="line"><span class="string">        """</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> l1 <span class="keyword">and</span> <span class="keyword">not</span> l2:</span><br><span class="line">            <span class="keyword">return</span> </span><br><span class="line">        <span class="keyword">elif</span> <span class="keyword">not</span> (l1 <span class="keyword">and</span> l2):</span><br><span class="line">            <span class="keyword">return</span> l1 <span class="keyword">or</span> l2</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">if</span> l1.val + l2.val &lt; <span class="number">10</span>:</span><br><span class="line">                l3 = ListNode(l1.val+l2.val)</span><br><span class="line">                l3.next = self.addTwoNumbers(l1.next, l2.next)</span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                l3 = ListNode(l1.val+l2.val<span class="number">-10</span>)</span><br><span class="line">                l3.next = self.addTwoNumbers(l1.next, self.addTwoNumbers(l2.next, ListNode(<span class="number">1</span>)))</span><br><span class="line">        <span class="keyword">return</span> l3</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 递归 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>机器人的运动范围</title>
      <link href="/2019/03/11/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/"/>
      <url>/2019/03/11/%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4/</url>
      
        <content type="html"><![CDATA[<p>地上有一个 m行和 n列的方格，横纵坐标范围分别是 0∼m−10∼m−1 和 0∼n−10∼n−1。</p><p>一个机器人从坐标0,0的格子开始移动，每一次只能向左，右，上，下四个方向移动一格。</p><p>但是不能进入行坐标和列坐标的数位之和大于 kk 的格子。</p><p>请问该机器人能够达到多少个格子？</p><a id="more"></a><h4 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：k=7, m=4, n=5</span><br><span class="line"></span><br><span class="line">输出：20</span><br></pre></td></tr></table></figure><h4 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入：k=18, m=40, n=40</span><br><span class="line"></span><br><span class="line">输出：1484</span><br><span class="line"></span><br><span class="line">解释：当k为18时，机器人能够进入方格（35,37），因为3+5+3+7 = 18。</span><br><span class="line">      但是，它不能进入方格（35,38），因为3+5+3+8 = 19。</span><br></pre></td></tr></table></figure><p><strong>注意</strong>:</p><ol><li>0&lt;=m&lt;=50</li><li>0&lt;=n&lt;=50</li><li>0&lt;=k&lt;=100</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">movingCount</span><span class="params">(self, threshold, rows, cols)</span>:</span></span><br><span class="line">        cnt = <span class="number">0</span></span><br><span class="line">        visited = [[<span class="literal">False</span>]*cols <span class="keyword">for</span> _  <span class="keyword">in</span> range(rows)]</span><br><span class="line">         </span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">dfs</span><span class="params">(x, y)</span>:</span></span><br><span class="line">            <span class="keyword">if</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=x&lt;rows) <span class="keyword">or</span> <span class="keyword">not</span> (<span class="number">0</span>&lt;=y&lt;cols) <span class="keyword">or</span>  visited[x][y] <span class="keyword">or</span> sum(map(int,str(x)+str(y))) &gt; threshold:</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">             </span><br><span class="line">            visited[x][y] = <span class="literal">True</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> +  dfs(x+<span class="number">1</span>,y) +  dfs(x<span class="number">-1</span>,y) + dfs(x,y+<span class="number">1</span>) + dfs(x,y<span class="number">-1</span>)         </span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">movingCount</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">bool</span> *flag = <span class="keyword">new</span> <span class="keyword">bool</span>[rows * cols];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; rows * cols; i++)</span><br><span class="line">            flag[i] = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> count = moving(threshold, rows, cols, <span class="number">0</span>, <span class="number">0</span>, flag);</span><br><span class="line">        <span class="keyword">return</span> count; </span><br><span class="line">    &#125;</span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">moving</span><span class="params">(<span class="keyword">int</span> threshold, <span class="keyword">int</span> rows, <span class="keyword">int</span> cols, <span class="keyword">int</span> i, <span class="keyword">int</span> j, <span class="keyword">bool</span>* flag)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= <span class="number">0</span> &amp;&amp; i &lt; rows &amp;&amp; j &gt;= <span class="number">0</span> &amp;&amp; j &lt; cols &amp;&amp; getsum(i) + getsum(j) &lt;= threshold &amp;&amp; flag[i * cols + j] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            flag[i * cols + j] = <span class="literal">true</span>;</span><br><span class="line">            count =<span class="number">1</span> + moving(threshold, rows, cols, i + <span class="number">1</span>, j, flag)</span><br><span class="line">                + moving(threshold, rows, cols, i - <span class="number">1</span>, j, flag)</span><br><span class="line">                + moving(threshold, rows, cols, i , j - <span class="number">1</span>, flag)</span><br><span class="line">                + moving(threshold, rows, cols, i, j + <span class="number">1</span>, flag);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getsum</span><span class="params">(<span class="keyword">int</span> num)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(num)</span><br><span class="line">            &#123;</span><br><span class="line">            sum += num % <span class="number">10</span>;</span><br><span class="line">            num /= <span class="number">10</span>;</span><br><span class="line">              </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><strong>1.从(0,0)开始走，每成功走一步标记当前位置为true,然后从当前位置往四个方向探索，</strong></p><p><strong>返回1 + 4 个方向的探索值之和。</strong></p><p><strong>2.探索时，判断当前节点是否可达的标准为：</strong></p><p>  1）当前节点在矩阵内</p><p>  2）当前节点未被访问过</p><p>  3）当前节点满足limit限制。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> dfs </tag>
            
            <tag> 回溯 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>杂念</title>
      <link href="/2019/03/10/%E6%9D%82%E5%BF%B5/"/>
      <url>/2019/03/10/%E6%9D%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<p>算了，本来想提笔写些什么的，但是写不出来，哪怕只是说与自己听。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 随笔 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>excel数据分析函数</title>
      <link href="/2019/03/10/excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/"/>
      <url>/2019/03/10/excel%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="自动插入排名"><a href="#自动插入排名" class="headerlink" title="自动插入排名"></a>自动插入排名</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">RANK.EQ(L16,$L$16:$L$25)</span><br></pre></td></tr></table></figure><ul><li><p>RANK.EQ 函数：返回某数字在一列数字中相对于其他数值的大小排名；如果多个数值排名相同，则返回该组数值的最佳排名</p><p>　<a id="more"></a>　</p></li></ul><h2 id="统计前3球队的平均积分"><a href="#统计前3球队的平均积分" class="headerlink" title="统计前3球队的平均积分"></a>统计前3球队的平均积分</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">AVERAGE(LARGE($L$16:$L$25,&#123;1;2;3&#125;))</span><br></pre></td></tr></table></figure><ul><li>LARGE 函数：返回数据集中第 k 个或前 k 个最大值</li><li>AVERAGE 函数：返回其参数的平均值</li></ul><h1 id="线性拟合"><a href="#线性拟合" class="headerlink" title="线性拟合"></a>线性拟合</h1><p>源数据</p><table><thead><tr><th style="text-align:center">7</th><th style="text-align:center">12600</th></tr></thead><tbody><tr><td style="text-align:center">8</td><td style="text-align:center">15600</td></tr><tr><td style="text-align:center">9</td><td style="text-align:center">9700</td></tr><tr><td style="text-align:center">10</td><td style="text-align:center">11360</td></tr><tr><td style="text-align:center">11</td><td style="text-align:center">15540</td></tr><tr><td style="text-align:center">12</td><td style="text-align:center">17480</td></tr></tbody></table><h2 id="LINEST"><a href="#LINEST" class="headerlink" title="LINEST"></a>LINEST</h2><p><img src="https://i.loli.net/2019/03/10/5c84e66d101e8.png" alt="函数图例"></p><p>参数说明：</p><ul><li>Known_y’s是目标值y,</li><li>Known_x’s是自变量x</li><li>stats 可选，是否返回附加回归统计值 </li><li>const 可选，是否将常量强制设置为0<h3 id="获取斜率和截距"><a href="#获取斜率和截距" class="headerlink" title="获取斜率和截距"></a>获取斜率和截距</h3>INDEX<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=INDEX(LINEST(B2:B7,A2:A7),1)  #斜率</span><br><span class="line">=INDEX(LINEST(B2:B7,A2:A7),2)  #截距</span><br></pre></td></tr></table></figure></li></ul><h2 id="TREND"><a href="#TREND" class="headerlink" title="TREND"></a>TREND</h2><p>返回预测的线性回归的值<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=TREND(B2:B7,A2:A7,A33:A38)</span><br></pre></td></tr></table></figure></p><h2 id="LOGEST"><a href="#LOGEST" class="headerlink" title="LOGEST"></a>LOGEST</h2><p>描述的曲线是：y=b*m^x<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=LOGEST(B2:B7,A2:A7,,1)</span><br></pre></td></tr></table></figure></p><h3 id="获取系数"><a href="#获取系数" class="headerlink" title="获取系数"></a>获取系数</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">=INDEX(LOGEST(B2:B7,A2:A7),1)  # m</span><br><span class="line">=INDEX(LOGEST(B2:B7,A2:A7),2)  # b</span><br></pre></td></tr></table></figure><h2 id="GROWTH"><a href="#GROWTH" class="headerlink" title="GROWTH"></a>GROWTH</h2><p>返回要预测的值 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">=GROWTH(B2:B7,A2:A7,A33:A38)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 数据分析 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>翻转二叉树</title>
      <link href="/2019/03/10/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
      <url>/2019/03/10/%E7%BF%BB%E8%BD%AC%E4%BA%8C%E5%8F%89%E6%A0%91/</url>
      
        <content type="html"><![CDATA[<p>翻转一棵二叉树。</p><a id="more"></a><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  2     7</span><br><span class="line"> / \   / \</span><br><span class="line">1   3 6   9</span><br><span class="line">输出：</span><br><span class="line"></span><br><span class="line">     4</span><br><span class="line">   /   \</span><br><span class="line">  7     2</span><br><span class="line"> / \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"># Definition for a binary tree node.</span><br><span class="line"># class TreeNode:</span><br><span class="line">#     def __init__(self, x):</span><br><span class="line">#         self.val = x</span><br><span class="line">#         self.left = None</span><br><span class="line">#         self.right = None</span><br><span class="line"></span><br><span class="line">class Solution:</span><br><span class="line">    def invertTree(self, root):</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        :type root: TreeNode</span><br><span class="line">        :rtype: TreeNode</span><br><span class="line">        &quot;&quot;&quot;</span><br><span class="line">        if root==None:</span><br><span class="line">            return root</span><br><span class="line">        root.left, root.right = root.right, root.left</span><br><span class="line">        self.invertTree(root.left)</span><br><span class="line">        self.invertTree(root.right)</span><br><span class="line">        return root</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 递归 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
    
  
</search>
